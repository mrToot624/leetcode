<p>给你一个&nbsp;<code>m x n</code>&nbsp;的迷宫矩阵&nbsp;<code>maze</code>&nbsp;（<strong>下标从 0 开始</strong>），矩阵中有空格子（用&nbsp;<code>'.'</code>&nbsp;表示）和墙（用&nbsp;<code>'+'</code>&nbsp;表示）。同时给你迷宫的入口&nbsp;<code>entrance</code>&nbsp;，用&nbsp;<code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code>&nbsp;表示你一开始所在格子的行和列。</p>

<p>每一步操作，你可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong> 或者 <strong>右</strong>&nbsp;移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离&nbsp;<code>entrance</code>&nbsp;<strong>最近</strong>&nbsp;的出口。<strong>出口</strong>&nbsp;的含义是&nbsp;<code>maze</code>&nbsp;<strong>边界</strong>&nbsp;上的&nbsp;<strong>空格子</strong>。<code>entrance</code>&nbsp;格子&nbsp;<strong>不算</strong>&nbsp;出口。</p>

<p>请你返回从 <code>entrance</code>&nbsp;到最近出口的最短路径的 <strong>步数</strong>&nbsp;，如果不存在这样的路径，请你返回 <code>-1</code>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg" style="width: 333px; height: 253px;"> <pre><b>输入：</b>maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
<b>输出：</b>1
<b>解释：</b>总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。
一开始，你在入口格子 (1,2) 处。
- 你可以往左移动 2 步到达 (1,0) 。
- 你可以往上移动 1 步到达 (0,2) 。
从入口处没法到达 (2,3) 。
所以，最近的出口是 (0,2) ，距离为 1 步。
</pre> </img>

<p><strong>示例 2：</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg" style="width: 253px; height: 253px;"> <pre><b>输入：</b>maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
<b>输出：</b>2
<b>解释：</b>迷宫中只有 1 个出口，在 (1,2) 处。
(1,0) 不算出口，因为它是入口格子。
初始时，你在入口与格子 (1,0) 处。
- 你可以往右移动 2 步到达 (1,2) 处。
所以，最近的出口为 (1,2) ，距离为 2 步。
</pre> </img>

<p><strong>示例 3：</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg" style="width: 173px; height: 93px;"> <pre><b>输入：</b>maze = [[".","+"]], entrance = [0,0]
<b>输出：</b>-1
<b>解释：</b>这个迷宫中没有出口。
</pre> </img>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>maze.length == m</code></li> 
 <li><code>maze[i].length == n</code></li> 
 <li><code>1 &lt;= m, n &lt;= 100</code></li> 
 <li><code>maze[i][j]</code> 要么是&nbsp;<code>'.'</code>&nbsp;，要么是&nbsp;<code>'+'</code>&nbsp;。</li> 
 <li><code>entrance.length == 2</code></li> 
 <li><code>0 &lt;= entrance<sub>row</sub> &lt; m</code></li> 
 <li><code>0 &lt;= entrance<sub>col</sub> &lt; n</code></li> 
 <li><code>entrance</code>&nbsp;一定是空格子。</li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>广度优先搜索 | 数组 | 矩阵</details><br>

<div>👍 132, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：为满足广大读者的需求，网站上架 [速成目录](https://labuladong.online/algo/intro/quick-learning-plan/)，如有需要可以看下，谢谢大家的支持~**

<details><summary><strong>labuladong 思路</strong></summary>


<div id="labuladong_solution_zh">

## 基本思路

这道题非常简单，就是标准的 BFS 算法，只要套用 [BFS 算法模板框架](https://labuladong.online/algo/essential-technique/bfs-framework/) 就可以了，直接看代码吧。另外我建议做一下 [$ ✨286. 墙与门](/problems/walls-and-gates/)，比这道题有意思一些。

**详细题解**：
  - [【练习】BFS 经典习题 I](https://labuladong.online/algo/problem-set/bfs/)

</div>





<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

#include <vector>
#include <queue>

class Solution {
public:
    int nearestExit(std::vector<std::vector<char>>& maze, std::vector<int>& entrance) {
        int m = maze.size();
        int n = maze[0].size();
        std::vector<std::vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // BFS 算法的队列和 visited 数组
        std::queue<std::vector<int>> queue;
        std::vector<std::vector<bool>> visited(m, std::vector<bool>(n, false));
        queue.push(entrance);
        visited[entrance[0]][entrance[1]] = true;
        
        // 启动 BFS 算法从 entrance 开始像四周扩散
        int step = 0;
        while (!queue.empty()) {
            int sz = queue.size();
            step++;
            // 扩散当前队列中的所有节点
            for (int i = 0; i < sz; i++) {
                std::vector<int> cur = queue.front();
                queue.pop();
                // 每个节点都会尝试向上下左右四个方向扩展一步
                for (const auto& dir : dirs) {
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || maze[x][y] == '+') {
                        continue;
                    }
                    if (x == 0 || x == m - 1 || y == 0 || y == n - 1) {
                        // 走到边界（出口）
                        return step;
                    }
                    visited[x][y] = true;
                    queue.push({x, y});
                }
            }
        }
        return -1;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

from collections import deque

class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        m = len(maze)
        n = len(maze[0])
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        # BFS 算法的队列和 visited 数组
        queue = deque()
        visited = [[False for _ in range(n)] for _ in range(m)]
        queue.append(entrance)
        visited[entrance[0]][entrance[1]] = True
        # 启动 BFS 算法从 entrance 开始像四周扩散
        step = 0
        while queue:
            sz = len(queue)
            step += 1
            # 扩散当前队列中的所有节点
            for i in range(sz):
                cur = queue.popleft()
                # 每个节点都会尝试向上下左右四个方向扩展一步
                for dir in dirs:
                    x = cur[0] + dir[0]
                    y = cur[1] + dir[1]
                    if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or maze[x][y] == '+':
                        continue
                    if x == 0 or x == m - 1 or y == 0 or y == n - 1:
                        # 走到边界（出口）
                        return step
                    visited[x][y] = True
                    queue.append([x, y])
        return -1
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        int m = maze.length;
        int n = maze[0].length;
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // BFS 算法的队列和 visited 数组
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[m][n];
        queue.offer(entrance);
        visited[entrance[0]][entrance[1]] = true;
        // 启动 BFS 算法从 entrance 开始像四周扩散
        int step = 0;
        while (!queue.isEmpty()) {
            int sz = queue.size();
            step++;
            // 扩散当前队列中的所有节点
            for (int i = 0; i < sz; i++) {
                int[] cur = queue.poll();
                // 每个节点都会尝试向上下左右四个方向扩展一步
                for (int[] dir : dirs) {
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n
                            || visited[x][y] || maze[x][y] == '+') {
                        continue;
                    }
                    if (x == 0 || x == m - 1 || y == 0 || y == n - 1) {
                        // 走到边界（出口）
                        return step;
                    }
                    visited[x][y] = true;
                    queue.offer(new int[]{x, y});
                }
            }
        }
        return -1;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

// BFS 算法的队列和 visited 数组
func nearestExit(maze [][]byte, entrance []int) int {
    m := len(maze)
    n := len(maze[0])
    dirs := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}
    
    queue := make([][]int, 0)
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }
    
    queue = append(queue, entrance)
    visited[entrance[0]][entrance[1]] = true
    
    // 启动 BFS 算法从 entrance 开始像四周扩散
    step := 0
    for len(queue) > 0 {
        sz := len(queue)
        step++
        // 扩散当前队列中的所有节点
        for i := 0; i < sz; i++ {
            cur := queue[0]
            queue = queue[1:]
            // 每个节点都会尝试向上下左右四个方向扩展一步
            for _, dir := range dirs {
                x := cur[0] + dir[0]
                y := cur[1] + dir[1]
                if x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || maze[x][y] == '+' {
                    continue
                }
                if x == 0 || x == m-1 || y == 0 || y == n-1 {
                    // 走到边界（出口）
                    return step
                }
                visited[x][y] = true
                queue = append(queue, []int{x, y})
            }
        }
    }
    return -1
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

var nearestExit = function(maze, entrance) {
    const m = maze.length;
    const n = maze[0].length;
    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    // BFS 算法的队列和 visited 数组
    const queue = [];
    const visited = Array.from({ length: m }, () => Array(n).fill(false));
    queue.push(entrance);
    visited[entrance[0]][entrance[1]] = true;
    // 启动 BFS 算法从 entrance 开始像四周扩散
    let step = 0;
    while (queue.length) {
        const sz = queue.length;
        step++;
        // 扩散当前队列中的所有节点
        for (let i = 0; i < sz; i++) {
            const cur = queue.shift();
            // 每个节点都会尝试向上下左右四个方向扩展一步
            for (const dir of dirs) {
                const x = cur[0] + dir[0];
                const y = cur[1] + dir[1];
                if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || maze[x][y] === '+') {
                    continue;
                }
                if (x === 0 || x === m - 1 || y === 0 || y === n - 1) {
                    // 走到边界（出口）
                    return step;
                }
                visited[x][y] = true;
                queue.push([x, y]);
            }
        }
    }
    return -1;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🎃🎃 算法可视化 🎃🎃</strong></summary><div id="data_nearest-exit-from-entrance-in-maze"  category="leetcode" ></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_nearest-exit-from-entrance-in-maze"></div></div>
</details><hr /><br />

</div>
</details>
</div>


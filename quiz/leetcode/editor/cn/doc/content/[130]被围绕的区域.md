<p>ç»™ä½ ä¸€ä¸ª <code>m x n</code> çš„çŸ©é˜µ <code>board</code> ï¼Œç”±è‹¥å¹²å­—ç¬¦ <code>'X'</code> å’Œ <code>'O'</code>&nbsp;ç»„æˆï¼Œ<strong>æ•è·</strong> æ‰€æœ‰ <strong>è¢«å›´ç»•çš„åŒºåŸŸ</strong>ï¼š</p>

<ul> 
 <li><strong>è¿æ¥ï¼š</strong>ä¸€ä¸ªå•å…ƒæ ¼ä¸æ°´å¹³æˆ–å‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„å•å…ƒæ ¼è¿æ¥ã€‚</li> 
 <li><strong>åŒºåŸŸï¼šè¿æ¥æ‰€æœ‰&nbsp;</strong><code>'O'</code>&nbsp;çš„å•å…ƒæ ¼æ¥å½¢æˆä¸€ä¸ªåŒºåŸŸã€‚</li> 
 <li><strong>å›´ç»•ï¼š</strong>å¦‚æœæ‚¨å¯ä»¥ç”¨&nbsp;<code>'X'</code>&nbsp;å•å…ƒæ ¼ <strong>è¿æ¥è¿™ä¸ªåŒºåŸŸ</strong>ï¼Œå¹¶ä¸”åŒºåŸŸä¸­æ²¡æœ‰ä»»ä½•å•å…ƒæ ¼ä½äº&nbsp;<code>board</code> è¾¹ç¼˜ï¼Œåˆ™è¯¥åŒºåŸŸè¢« <code>'X'</code>&nbsp;å•å…ƒæ ¼å›´ç»•ã€‚</li> 
</ul>

<p>é€šè¿‡ <strong>åŸåœ°</strong>&nbsp;å°†è¾“å…¥çŸ©é˜µä¸­çš„æ‰€æœ‰ <code>'O'</code>&nbsp;æ›¿æ¢ä¸º <code>'X'</code> æ¥ <strong>æ•è·è¢«å›´ç»•çš„åŒºåŸŸ</strong>ã€‚ä½ ä¸éœ€è¦è¿”å›ä»»ä½•å€¼ã€‚</p>

<div class="original__bRMd"> 
 <div> 
  <p>&nbsp;</p> 
 </div>
</div>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<div class="example-block"> 
 <p><strong>è¾“å…¥ï¼š</strong><span class="example-io">board = [['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']]</span></p> 
</div>

<p><b>è¾“å‡ºï¼š</b><span class="example-io">[['X','X','X','X'],['X','X','X','X'],['X','X','X','X'],['X','O','X','X']]</span></p>

<p><strong>è§£é‡Šï¼š</strong></p> 
<img alt="" src="https://pic.leetcode.cn/1718167191-XNjUTG-image.png" style="width: 367px; height: 158px;" /> 
<p>åœ¨ä¸Šå›¾ä¸­ï¼Œåº•éƒ¨çš„åŒºåŸŸæ²¡æœ‰è¢«æ•è·ï¼Œå› ä¸ºå®ƒåœ¨ board çš„è¾¹ç¼˜å¹¶ä¸”ä¸èƒ½è¢«å›´ç»•ã€‚</p>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<div class="example-block"> 
 <p><strong>è¾“å…¥ï¼š</strong><span class="example-io">board = [['X']]</span></p> 
</div>

<p><strong>è¾“å‡ºï¼š</strong><span class="example-io">[['X']]</span></p>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul> 
 <li><code>m == board.length</code></li> 
 <li><code>n == board[i].length</code></li> 
 <li><code>1 &lt;= m, n &lt;= 200</code></li> 
 <li><code>board[i][j]</code> ä¸º <code>'X'</code> æˆ– <code>'O'</code></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>æ·±åº¦ä¼˜å…ˆæœç´¢ | å¹¿åº¦ä¼˜å…ˆæœç´¢ | å¹¶æŸ¥é›† | æ•°ç»„ | çŸ©é˜µ</details><br>

<div>ğŸ‘ 1239, ğŸ‘ 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug åé¦ˆ</a> | <a href='https://labuladong.online/algo/fname.html?fname=jbæ’ä»¶ç®€ä»‹' target='_blank' style='color: lightgray;text-decoration: underline;'>ä½¿ç”¨æŒ‡å—</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>æ›´å¤šé…å¥—æ’ä»¶</a></span></span></div>

<div id="labuladong"><hr>

**é€šçŸ¥ï¼šä¸ºæ»¡è¶³å¹¿å¤§è¯»è€…çš„éœ€æ±‚ï¼Œç½‘ç«™ä¸Šæ¶ [é€Ÿæˆç›®å½•](https://labuladong.online/algo/intro/quick-learning-plan/)ï¼Œå¦‚æœ‰éœ€è¦å¯ä»¥çœ‹ä¸‹ï¼Œè°¢è°¢å¤§å®¶çš„æ”¯æŒ~**



<p><strong><a href="https://labuladong.online/algo/data-structure/union-find/" target="_blank">â­ï¸labuladong é¢˜è§£</a></strong></p>
<details><summary><strong>labuladong æ€è·¯</strong></summary>


<div id="labuladong_solution_zh">

## åŸºæœ¬æ€è·¯

è¿™é¢˜å’Œ [âœ” âœ¨1254. ç»Ÿè®¡å°é—­å²›å±¿çš„æ•°ç›®](/problems/number-of-closed-islands/) å‡ ä¹å®Œå…¨ä¸€æ ·ï¼Œå¸¸è§„åšæ³•å°±æ˜¯ DFSï¼Œé‚£æˆ‘ä»¬è¿™é‡Œå°±è®²ä¸€ä¸ªå¦ç±»çš„è§£æ³•ï¼Œçœ‹çœ‹å¹¶æŸ¥é›†ç®—æ³•å¦‚ä½•è§£å†³è¿™é“é¢˜ã€‚

æˆ‘ä»¬å¯ä»¥æŠŠæ‰€æœ‰é è¾¹çš„ `O` å’Œä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ `dummy` è¿›è¡Œè¿é€šï¼š

![](https://labuladong.online/algo/images/unionfind-in-action/3.jpg)

ç„¶åå†éå†æ•´ä¸ª `board`ï¼Œé‚£äº›å’Œ `dummy` ä¸è¿é€šçš„ `O` å°±æ˜¯è¢«å›´ç»•çš„åŒºåŸŸï¼Œéœ€è¦è¢«æ›¿æ¢ã€‚

**è¯¦ç»†é¢˜è§£**ï¼š
  - [Union-Find å¹¶æŸ¥é›†ç®—æ³•](https://labuladong.online/algo/data-structure/union-find/)

</div>





<div id="solution">

## è§£æ³•ä»£ç 



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cppğŸ¤–</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">pythonğŸ¤–</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">javağŸŸ¢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">goğŸ¤–</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascriptğŸ¤–</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// æ³¨æ„ï¼šcpp ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ã€‚
// æœ¬ä»£ç çš„æ­£ç¡®æ€§å·²é€šè¿‡åŠ›æ‰£éªŒè¯ï¼Œå¦‚æœ‰ç–‘é—®ï¼Œå¯ä»¥å¯¹ç…§ java ä»£ç æŸ¥çœ‹ã€‚

class UF {
private:
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    int count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    std::vector<int> parent;
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    std::vector<int> size;

public:
    UF(int n) : count(n), parent(n), size(n, 1) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    // å°† p å’Œ q è¿é€š
    void unionSet(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    // åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ;
    }

    // è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹
    int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    int countComponents() {
        return count;
    }
};

class Solution {
public:
    void solve(std::vector<std::vector<char>>& board) {
        if (board.empty()) return;

        int m = board.size();
        int n = board[0].size();
        // ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
        UF uf(m * n + 1);
        int dummy = m * n;
        // å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O')
                uf.unionSet(i * n, dummy);
            if (board[i][n - 1] == 'O')
                uf.unionSet(i * n + n - 1, dummy);
        }
        // å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
        for (int j = 0; j < n; j++) {
            if (board[0][j] == 'O')
                uf.unionSet(j, dummy);
            if (board[m - 1][j] == 'O')
                uf.unionSet(n * (m - 1) + j, dummy);
        }
        // æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•
        std::vector<std::vector<int>> d{{1, 0}, {0, 1}, {0, -1}, {-1, 0}};
        for (int i = 1; i < m - 1; i++)
            for (int j = 1; j < n - 1; j++)
                if (board[i][j] == 'O')
                    // å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                    for (int k = 0; k < 4; k++) {
                        int x = i + d[k][0];
                        int y = j + d[k][1];
                        if (board[x][y] == 'O')
                            uf.unionSet(x * n + y, i * n + j);
                    }
        // æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
        for (int i = 1; i < m - 1; i++)
            for (int j = 1; j < n - 1; j++)
                if (!uf.connected(dummy, i * n + j))
                    board[i][j] = 'X';
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# æ³¨æ„ï¼špython ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ã€‚
# æœ¬ä»£ç çš„æ­£ç¡®æ€§å·²é€šè¿‡åŠ›æ‰£éªŒè¯ï¼Œå¦‚æœ‰ç–‘é—®ï¼Œå¯ä»¥å¯¹ç…§ java ä»£ç æŸ¥çœ‹ã€‚

class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return

        m = len(board)
        n = len(board[0])
        # ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
        uf = UF(m * n + 1)
        dummy = m * n
        # å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
        for i in range(m):
            if board[i][0] == 'O':
                uf.union(i * n, dummy)
            if board[i][n - 1] == 'O':
                uf.union(i * n + n - 1, dummy)
        # å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
        for j in range(n): # <extend up -150>![](https://labuladong.online/algo/images/unionfind-in-action/3.jpg) #
            if board[0][j] == 'O':
                uf.union(j, dummy)
            if board[m - 1][j] == 'O':
                uf.union(n * (m - 1) + j, dummy)
        # æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•
        d = [[1, 0], [0, 1], [0, -1], [-1, 0]]
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                if board[i][j] == 'O':
                    # å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                    for k in range(4):
                        x = i + d[k][0]
                        y = j + d[k][1]
                        if board[x][y] == 'O':
                            uf.union(x * n + y, i * n + j)
        # æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                if not uf.connected(dummy, i * n + j):
                    board[i][j] = 'X'

class UF:
    # è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    def __init__(self, n: int):
        self.count = n
        # å­˜å‚¨è‹¥å¹²æ£µæ ‘
        self.parent = list(range(n))
        # è®°å½•æ ‘çš„â€œé‡é‡â€
        self.size = [1] * n

    # å°† p å’Œ q è¿é€š
    def union(self, p: int, q: int) -> None:
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return

        # å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if self.size[rootP] > self.size[rootQ]:
            self.parent[rootQ] = rootP
            self.size[rootP] += self.size[rootQ]
        else:
            self.parent[rootP] = rootQ
            self.size[rootQ] += self.size[rootP]
        self.count -= 1

    # åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š
    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        # å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ

    # è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            # è¿›è¡Œè·¯å¾„å‹ç¼©
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def count(self) -> int:
        return self.count
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public void solve(char[][] board) {
        if (board.length == 0) return;

        int m = board.length;
        int n = board[0].length;
        // ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
        UF uf = new UF(m * n + 1);
        int dummy = m * n;
        // å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O')
                uf.union(i * n, dummy);
            if (board[i][n - 1] == 'O')
                uf.union(i * n + n - 1, dummy);
        }
        // å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
        for (int j = 0; j < n; j++) {/**<extend up -150>![](https://labuladong.online/algo/images/unionfind-in-action/3.jpg) */
            if (board[0][j] == 'O')
                uf.union(j, dummy);
            if (board[m - 1][j] == 'O')
                uf.union(n * (m - 1) + j, dummy);
        }
        // æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•
        int[][] d = new int[][]{{1, 0}, {0, 1}, {0, -1}, {-1, 0}};
        for (int i = 1; i < m - 1; i++)
            for (int j = 1; j < n - 1; j++)
                if (board[i][j] == 'O')
                    // å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                    for (int k = 0; k < 4; k++) {
                        int x = i + d[k][0];
                        int y = j + d[k][1];
                        if (board[x][y] == 'O')
                            uf.union(x * n + y, i * n + j);
                    }
        // æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
        for (int i = 1; i < m - 1; i++)
            for (int j = 1; j < n - 1; j++)
                if (!uf.connected(dummy, i * n + j))
                    board[i][j] = 'X';
    }
}

class UF {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    private int count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    private int[] parent;
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    // å°† p å’Œ q è¿é€š
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    // åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ;
    }

    // è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹
    private int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// æ³¨æ„ï¼šgo ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ã€‚
// æœ¬ä»£ç çš„æ­£ç¡®æ€§å·²é€šè¿‡åŠ›æ‰£éªŒè¯ï¼Œå¦‚æœ‰ç–‘é—®ï¼Œå¯ä»¥å¯¹ç…§ java ä»£ç æŸ¥çœ‹ã€‚

type UF struct {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    componentCount int
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    parent []int
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    size   []int
}

func NewUF(n int) *UF {
    uf := &UF{
        componentCount: n,
        parent: make([]int, n),
        size:   make([]int, n),
    }
    for i := 0; i < n; i++ {
        uf.parent[i] = i
        uf.size[i] = 1
    }
    return uf
}

// å°† p å’Œ q è¿é€š
func (uf *UF) union(p, q int) {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    if rootP == rootQ {
        return
    }

    // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
    if uf.size[rootP] > uf.size[rootQ] {
        uf.parent[rootQ] = rootP
        uf.size[rootP] += uf.size[rootQ]
    } else {
        uf.parent[rootP] = rootQ
        uf.size[rootQ] += uf.size[rootP]
    }
    uf.componentCount--
}

// åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š
func (uf *UF) connected(p, q int) bool {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
    return rootP == rootQ
}

// è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹
func (uf *UF) find(x int) int {
    for uf.parent[x] != x {
        // è¿›è¡Œè·¯å¾„å‹ç¼©
        uf.parent[x] = uf.parent[uf.parent[x]]
        x = uf.parent[x]
    }
    return x
}

func (uf *UF) count() int {
    return uf.componentCount
}

func solve(board [][]byte) {
    if len(board) == 0 {
        return
    }

    m := len(board)
    n := len(board[0])
    // ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
    uf := NewUF(m*n + 1)
    dummy := m * n
    // å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
    for i := 0; i < m; i++ {
        if board[i][0] == 'O' {
            uf.union(i*n, dummy)
        }
        if board[i][n-1] == 'O' {
            uf.union(i*n+n-1, dummy)
        }
    }
    // å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
    for j := 0; j < n; j++ {
        if board[0][j] == 'O' {
            uf.union(j, dummy)
        }
        if board[m-1][j] == 'O' {
            uf.union(n*(m-1)+j, dummy)
        }
    }
    // æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•
    d := [][]int{{1, 0}, {0, 1}, {0, -1}, {-1, 0}}
    for i := 1; i < m-1; i++ {
        for j := 1; j < n-1; j++ {
            if board[i][j] == 'O' {
                // å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                for k := 0; k < 4; k++ {
                    x := i + d[k][0]
                    y := j + d[k][1]
                    if board[x][y] == 'O' {
                        uf.union(x*n+y, i*n+j)
                    }
                }
            }
        }
    }
    // æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
    for i := 1; i < m-1; i++ {
        for j := 1; j < n-1; j++ {
            if !uf.connected(dummy, i*n+j) {
                board[i][j] = 'X'
            }
        }
    }
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// æ³¨æ„ï¼šjavascript ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ã€‚
// æœ¬ä»£ç çš„æ­£ç¡®æ€§å·²é€šè¿‡åŠ›æ‰£éªŒè¯ï¼Œå¦‚æœ‰ç–‘é—®ï¼Œå¯ä»¥å¯¹ç…§ java ä»£ç æŸ¥çœ‹ã€‚

var solve = function(board) {
    if (board.length === 0) return;

    const m = board.length;
    const n = board[0].length;
    // ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
    const uf = new UF(m * n + 1);
    const dummy = m * n;
    // å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
    for (let i = 0; i < m; i++) {
        if (board[i][0] === 'O')
            uf.union(i * n, dummy);
        if (board[i][n - 1] === 'O')
            uf.union(i * n + n - 1, dummy);
    }
    // å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
    for (let j = 0; j < n; j++) {
        if (board[0][j] === 'O')
            uf.union(j, dummy);
        if (board[m - 1][j] === 'O')
            uf.union(n * (m - 1) + j, dummy);
    }
    // æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•
    const d = [[1, 0], [0, 1], [0, -1], [-1, 0]];
    for (let i = 1; i < m - 1; i++)
        for (let j = 1; j < n - 1; j++)
            if (board[i][j] === 'O')
                // å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                for (let k = 0; k < 4; k++) {
                    const x = i + d[k][0];
                    const y = j + d[k][1];
                    if (board[x][y] === 'O')
                        uf.union(x * n + y, i * n + j);
                }
    // æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
    for (let i = 1; i < m - 1; i++)
        for (let j = 1; j < n - 1; j++)
            if (!uf.connected(dummy, i * n + j))
                board[i][j] = 'X';
};

class UF {
    constructor(n) {
        // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
        this.count = n;
        // å­˜å‚¨è‹¥å¹²æ£µæ ‘
        this.parent = new Array(n);
        // è®°å½•æ ‘çš„â€œé‡é‡â€
        this.size = new Array(n);
        for (let i = 0; i < n; i++) {
            this.parent[i] = i;
            this.size[i] = 1;
        }
    }

    // å°† p å’Œ q è¿é€š
    union(p, q) {
        const rootP = this.find(p);
        const rootQ = this.find(q);
        if (rootP === rootQ) return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (this.size[rootP] > this.size[rootQ]) {
            this.parent[rootQ] = rootP;
            this.size[rootP] += this.size[rootQ];
        } else {
            this.parent[rootP] = rootQ;
            this.size[rootQ] += this.size[rootP];
        }
        this.count--;
    }

    // åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š
    connected(p, q) {
        const rootP = this.find(p);
        const rootQ = this.find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP === rootQ;
    }

    // è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹
    find(x) {
        while (this.parent[x] !== x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            this.parent[x] = this.parent[this.parent[x]];
            x = this.parent[x];
        }
        return x;
    }

    count() {
        return this.count;
    }
}
```

</div></div>
</div></div>

</div>
</details>
</div>


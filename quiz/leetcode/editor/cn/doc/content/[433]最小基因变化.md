<p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 <code>'A'</code>、<code>'C'</code>、<code>'G'</code> 和 <code>'T'</code> 之一。</p>

<p>假设我们需要调查从基因序列&nbsp;<code>start</code> 变为 <code>end</code> 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p>

<ul> 
 <li>例如，<code>"AACCGGTT" --&gt; "AACCGGTA"</code> 就是一次基因变化。</li> 
</ul>

<p>另有一个基因库 <code>bank</code> 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 <code>bank</code> 中）</p>

<p>给你两个基因序列 <code>start</code> 和 <code>end</code> ，以及一个基因库 <code>bank</code> ，请你找出并返回能够使&nbsp;<code>start</code> 变化为 <code>end</code> 所需的最少变化次数。如果无法完成此基因变化，返回 <code>-1</code> 。</p>

<p>注意：起始基因序列&nbsp;<code>start</code> 默认是有效的，但是它并不一定会出现在基因库中。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
<strong>输出：</strong>1
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
<strong>输出：</strong>2
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>start = "AAAAACCC", end = "AACCCCCC", bank = ["AAAACCCC","AAACCCCC","AACCCCCC"]
<strong>输出：</strong>3
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>start.length == 8</code></li> 
 <li><code>end.length == 8</code></li> 
 <li><code>0 &lt;= bank.length &lt;= 10</code></li> 
 <li><code>bank[i].length == 8</code></li> 
 <li><code>start</code>、<code>end</code> 和 <code>bank[i]</code> 仅由字符 <code>['A', 'C', 'G', 'T']</code> 组成</li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>广度优先搜索 | 哈希表 | 字符串</details><br>

<div>👍 335, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：为满足广大读者的需求，网站上架 [速成目录](https://labuladong.online/algo/intro/quick-learning-plan/)，如有需要可以看下，谢谢大家的支持~**

<details><summary><strong>labuladong 思路</strong></summary>


<div id="labuladong_solution_zh">

## 基本思路

心里那棵四叉树出来没有？有了那棵四叉树，这就是标准的 BFS 算法对吧，直接套用 [BFS 算法框架](https://labuladong.online/algo/essential-technique/bfs-framework/) 就行了。

**详细题解**：
  - [【练习】BFS 经典习题 I](https://labuladong.online/algo/problem-set/bfs/)

</div>





<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

class Solution {
public:
    int minMutation(string startGene, string endGene, vector<string>& bank) {
        unordered_set<string> bankSet(bank.begin(), bank.end());
        if (bankSet.find(endGene) == bankSet.end()) {
            return -1;
        }
        vector<char> AGCT = {'A', 'G', 'C', 'T'};

        // BFS 标准框架
        queue<string> q;
        unordered_set<string> visited;
        q.push(startGene);
        visited.insert(startGene);
        int step = 0;
        while (!q.empty()) {
            int sz = q.size();
            for (int j = 0; j < sz; j++) {
                string cur = q.front();
                q.pop();
                if (cur == endGene) {
                    return step;
                }
                // 向周围扩散
                for (const string& newGene : getAllMutation(cur)) {
                    if (visited.find(newGene) == visited.end() && bankSet.find(newGene) != bankSet.end()) {
                        q.push(newGene);
                        visited.insert(newGene);
                    }
                }
            }
            step++;
        }
        return -1;
    }

    // 当前基因的每个位置都可以变异为 A/G/C/T，穷举所有可能的结构
    vector<string> getAllMutation(const string& gene) {
        vector<string> res;
        string geneChars = gene;
        for (int i = 0; i < geneChars.length(); i++) {
            char oldChar = geneChars[i];
            for (char newChar : vector<char>{'A', 'G', 'C', 'T'}) {
                geneChars[i] = newChar;
                res.push_back(geneChars);
            }
            geneChars[i] = oldChar;
        }
        return res;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

class Solution:
    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        bankSet = set(bank)
        if endGene not in bankSet:
            return -1
        AGCT = ['A', 'G', 'C', 'T']

        # BFS 标准框架
        q = collections.deque()
        visited = set()
        q.append(startGene)
        visited.add(startGene)
        step = 0
        while q:
            sz = len(q)
            for j in range(sz):
                cur = q.popleft()
                if cur == endGene:
                    return step
                # 向周围扩散
                for newGene in self.getAllMutation(cur):
                    if newGene not in visited and newGene in bankSet:
                        q.append(newGene)
                        visited.add(newGene)
            step += 1
        return -1

    # 当前基因的每个位置都可以变异为 A/G/C/T，穷举所有可能的结构
    def getAllMutation(self, gene: str) -> List[str]:
        res = []
        geneChars = list(gene)
        for i in range(len(geneChars)):
            oldChar = geneChars[i]
            for newChar in ['A', 'G', 'C', 'T']:
                geneChars[i] = newChar
                res.append("".join(geneChars))
            geneChars[i] = oldChar
        return res
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public int minMutation(String startGene, String endGene, String[] bank) {
        Set<String> bankSet = new HashSet<>(Arrays.asList(bank));
        if (!bankSet.contains(endGene)) {
            return -1;
        }
        char[] AGCT = {'A', 'G', 'C', 'T'};

        // BFS 标准框架
        Queue<String> q = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        q.offer(startGene);
        visited.add(startGene);
        int step = 0;
        while (!q.isEmpty()) {
            int sz = q.size();
            for (int j = 0; j < sz; j++) {
                String cur = q.poll();
                if (cur.equals(endGene)) {
                    return step;
                }
                // 向周围扩散
                for (String newGene : getAllMutation(cur)) {
                    if (!visited.contains(newGene) && bankSet.contains(newGene)) {
                        q.offer(newGene);
                        visited.add(newGene);
                    }
                }
            }
            step++;
        }
        return -1;
    }

    // 当前基因的每个位置都可以变异为 A/G/C/T，穷举所有可能的结构
    List<String> getAllMutation(String gene) {
        List<String> res = new ArrayList<>();
        char[] geneChars = gene.toCharArray();
        for (int i = 0; i < geneChars.length; i++) {
            char oldChar = geneChars[i];
            for (char newChar : new char[]{'A', 'G', 'C', 'T'}) {
                geneChars[i] = newChar;
                res.add(new String(geneChars));
            }
            geneChars[i] = oldChar;
        }
        return res;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

func minMutation(startGene string, endGene string, bank []string) int {
    bankSet := make(map[string]struct{})
    for _, gene := range bank {
        bankSet[gene] = struct{}{}
    }
    if _, exists := bankSet[endGene]; !exists {
        return -1
    }

    // BFS 标准框架
    q := []string{startGene}
    visited := make(map[string]struct{})
    visited[startGene] = struct{}{}
    step := 0
    for len(q) > 0 {
        sz := len(q)
        for j := 0; j < sz; j++ {
            cur := q[0]
            q = q[1:]
            if cur == endGene {
                return step
            }
            // 向周围扩散
            for _, newGene := range getAllMutation(cur) {
                if _, seen := visited[newGene]; !seen {
                    if _, valid := bankSet[newGene]; valid {
                        q = append(q, newGene)
                        visited[newGene] = struct{}{}
                    }
                }
            }
        }
        step++
    }
    return -1
}

// 当前基因的每个位置都可以变异为 A/G/C/T，穷举所有可能的结构
func getAllMutation(gene string) []string {
    res := []string{}
    geneChars := []rune(gene)
    for i := 0; i < len(geneChars); i++ {
        oldChar := geneChars[i]
        for _, newChar := range []rune{'A', 'G', 'C', 'T'} {
            if newChar != oldChar {
                geneChars[i] = newChar
                res = append(res, string(geneChars))
            }
        }
        geneChars[i] = oldChar
    }
    return res
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

var minMutation = function(startGene, endGene, bank) {
    const bankSet = new Set(bank);
    if (!bankSet.has(endGene)) {
        return -1;
    }
    const AGCT = ['A', 'G', 'C', 'T'];

    // BFS 标准框架
    const q = [];
    const visited = new Set();
    q.push(startGene);
    visited.add(startGene);
    let step = 0;
    while (q.length > 0) {
        const sz = q.length;
        for (let j = 0; j < sz; j++) {
            const cur = q.shift();
            if (cur === endGene) {
                return step;
            }
            // 向周围扩散
            for (const newGene of getAllMutation(cur)) {
                if (!visited.has(newGene) && bankSet.has(newGene)) {
                    q.push(newGene);
                    visited.add(newGene);
                }
            }
        }
        step++;
    }
    return -1;
};

// 当前基因的每个位置都可以变异为 A/G/C/T，穷举所有可能的结构
var getAllMutation = function(gene) {
    const res = [];
    const geneChars = gene.split('');
    for (let i = 0; i < geneChars.length; i++) {
        const oldChar = geneChars[i];
        for (const newChar of ['A', 'G', 'C', 'T']) {
            geneChars[i] = newChar;
            res.push(geneChars.join(''));
        }
        geneChars[i] = oldChar;
    }
    return res;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>👾👾 算法可视化 👾👾</strong></summary><div id="data_minimum-genetic-mutation"  category="leetcode" ></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_minimum-genetic-mutation"></div></div>
</details><hr /><br />

</div>
</details>
</div>


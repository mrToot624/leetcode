<p>ç»™ä½ ä¸€ä¸ª&nbsp;<code>m x n</code>&nbsp;çš„è¿·å®«çŸ©é˜µ&nbsp;<code>maze</code>&nbsp;ï¼ˆ<strong>ä¸‹æ ‡ä» 0 å¼€å§‹</strong>ï¼‰ï¼ŒçŸ©é˜µä¸­æœ‰ç©ºæ ¼å­ï¼ˆç”¨&nbsp;<code>'.'</code>&nbsp;è¡¨ç¤ºï¼‰å’Œå¢™ï¼ˆç”¨&nbsp;<code>'+'</code>&nbsp;è¡¨ç¤ºï¼‰ã€‚åŒæ—¶ç»™ä½ è¿·å®«çš„å…¥å£&nbsp;<code>entrance</code>&nbsp;ï¼Œç”¨&nbsp;<code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code>&nbsp;è¡¨ç¤ºä½ ä¸€å¼€å§‹æ‰€åœ¨æ ¼å­çš„è¡Œå’Œåˆ—ã€‚</p>

<p>æ¯ä¸€æ­¥æ“ä½œï¼Œä½ å¯ä»¥å¾€ <strong>ä¸Š</strong>ï¼Œ<strong>ä¸‹</strong>ï¼Œ<strong>å·¦</strong> æˆ–è€… <strong>å³</strong>&nbsp;ç§»åŠ¨ä¸€ä¸ªæ ¼å­ã€‚ä½ ä¸èƒ½è¿›å…¥å¢™æ‰€åœ¨çš„æ ¼å­ï¼Œä½ ä¹Ÿä¸èƒ½ç¦»å¼€è¿·å®«ã€‚ä½ çš„ç›®æ ‡æ˜¯æ‰¾åˆ°ç¦»&nbsp;<code>entrance</code>&nbsp;<strong>æœ€è¿‘</strong>&nbsp;çš„å‡ºå£ã€‚<strong>å‡ºå£</strong>&nbsp;çš„å«ä¹‰æ˜¯&nbsp;<code>maze</code>&nbsp;<strong>è¾¹ç•Œ</strong>&nbsp;ä¸Šçš„&nbsp;<strong>ç©ºæ ¼å­</strong>ã€‚<code>entrance</code>&nbsp;æ ¼å­&nbsp;<strong>ä¸ç®—</strong>&nbsp;å‡ºå£ã€‚</p>

<p>è¯·ä½ è¿”å›ä» <code>entrance</code>&nbsp;åˆ°æœ€è¿‘å‡ºå£çš„æœ€çŸ­è·¯å¾„çš„ <strong>æ­¥æ•°</strong>&nbsp;ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è·¯å¾„ï¼Œè¯·ä½ è¿”å› <code>-1</code>&nbsp;ã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg" style="width: 333px; height: 253px;"> <pre><b>è¾“å…¥ï¼š</b>maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
<b>è¾“å‡ºï¼š</b>1
<b>è§£é‡Šï¼š</b>æ€»å…±æœ‰ 3 ä¸ªå‡ºå£ï¼Œåˆ†åˆ«ä½äº (1,0)ï¼Œ(0,2) å’Œ (2,3) ã€‚
ä¸€å¼€å§‹ï¼Œä½ åœ¨å…¥å£æ ¼å­ (1,2) å¤„ã€‚
- ä½ å¯ä»¥å¾€å·¦ç§»åŠ¨ 2 æ­¥åˆ°è¾¾ (1,0) ã€‚
- ä½ å¯ä»¥å¾€ä¸Šç§»åŠ¨ 1 æ­¥åˆ°è¾¾ (0,2) ã€‚
ä»å…¥å£å¤„æ²¡æ³•åˆ°è¾¾ (2,3) ã€‚
æ‰€ä»¥ï¼Œæœ€è¿‘çš„å‡ºå£æ˜¯ (0,2) ï¼Œè·ç¦»ä¸º 1 æ­¥ã€‚
</pre> </img>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg" style="width: 253px; height: 253px;"> <pre><b>è¾“å…¥ï¼š</b>maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
<b>è¾“å‡ºï¼š</b>2
<b>è§£é‡Šï¼š</b>è¿·å®«ä¸­åªæœ‰ 1 ä¸ªå‡ºå£ï¼Œåœ¨ (1,2) å¤„ã€‚
(1,0) ä¸ç®—å‡ºå£ï¼Œå› ä¸ºå®ƒæ˜¯å…¥å£æ ¼å­ã€‚
åˆå§‹æ—¶ï¼Œä½ åœ¨å…¥å£ä¸æ ¼å­ (1,0) å¤„ã€‚
- ä½ å¯ä»¥å¾€å³ç§»åŠ¨ 2 æ­¥åˆ°è¾¾ (1,2) å¤„ã€‚
æ‰€ä»¥ï¼Œæœ€è¿‘çš„å‡ºå£ä¸º (1,2) ï¼Œè·ç¦»ä¸º 2 æ­¥ã€‚
</pre> </img>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg" style="width: 173px; height: 93px;"> <pre><b>è¾“å…¥ï¼š</b>maze = [[".","+"]], entrance = [0,0]
<b>è¾“å‡ºï¼š</b>-1
<b>è§£é‡Šï¼š</b>è¿™ä¸ªè¿·å®«ä¸­æ²¡æœ‰å‡ºå£ã€‚
</pre> </img>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul> 
 <li><code>maze.length == m</code></li> 
 <li><code>maze[i].length == n</code></li> 
 <li><code>1 &lt;= m, n &lt;= 100</code></li> 
 <li><code>maze[i][j]</code> è¦ä¹ˆæ˜¯&nbsp;<code>'.'</code>&nbsp;ï¼Œè¦ä¹ˆæ˜¯&nbsp;<code>'+'</code>&nbsp;ã€‚</li> 
 <li><code>entrance.length == 2</code></li> 
 <li><code>0 &lt;= entrance<sub>row</sub> &lt; m</code></li> 
 <li><code>0 &lt;= entrance<sub>col</sub> &lt; n</code></li> 
 <li><code>entrance</code>&nbsp;ä¸€å®šæ˜¯ç©ºæ ¼å­ã€‚</li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>å¹¿åº¦ä¼˜å…ˆæœç´¢ | æ•°ç»„ | çŸ©é˜µ</details><br>

<div>ğŸ‘ 132, ğŸ‘ 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug åé¦ˆ</a> | <a href='https://labuladong.online/algo/fname.html?fname=jbæ’ä»¶ç®€ä»‹' target='_blank' style='color: lightgray;text-decoration: underline;'>ä½¿ç”¨æŒ‡å—</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>æ›´å¤šé…å¥—æ’ä»¶</a></span></span></div>

<div id="labuladong"><hr>

**é€šçŸ¥ï¼šä¸ºæ»¡è¶³å¹¿å¤§è¯»è€…çš„éœ€æ±‚ï¼Œç½‘ç«™ä¸Šæ¶ [é€Ÿæˆç›®å½•](https://labuladong.online/algo/intro/quick-learning-plan/)ï¼Œå¦‚æœ‰éœ€è¦å¯ä»¥çœ‹ä¸‹ï¼Œè°¢è°¢å¤§å®¶çš„æ”¯æŒ~**

<details><summary><strong>labuladong æ€è·¯</strong></summary>


<div id="labuladong_solution_zh">

## åŸºæœ¬æ€è·¯

è¿™é“é¢˜éå¸¸ç®€å•ï¼Œå°±æ˜¯æ ‡å‡†çš„ BFS ç®—æ³•ï¼Œåªè¦å¥—ç”¨ [BFS ç®—æ³•æ¨¡æ¿æ¡†æ¶](https://labuladong.online/algo/essential-technique/bfs-framework/) å°±å¯ä»¥äº†ï¼Œç›´æ¥çœ‹ä»£ç å§ã€‚å¦å¤–æˆ‘å»ºè®®åšä¸€ä¸‹ [$ âœ¨286. å¢™ä¸é—¨](/problems/walls-and-gates/)ï¼Œæ¯”è¿™é“é¢˜æœ‰æ„æ€ä¸€äº›ã€‚

**è¯¦ç»†é¢˜è§£**ï¼š
  - [ã€ç»ƒä¹ ã€‘BFS ç»å…¸ä¹ é¢˜ I](https://labuladong.online/algo/problem-set/bfs/)

</div>





<div id="solution">

## è§£æ³•ä»£ç 



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cppğŸ¤–</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">pythonğŸ¤–</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">javağŸŸ¢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">goğŸ¤–</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascriptğŸ¤–</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// æ³¨æ„ï¼šcpp ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ã€‚
// æœ¬ä»£ç çš„æ­£ç¡®æ€§å·²é€šè¿‡åŠ›æ‰£éªŒè¯ï¼Œå¦‚æœ‰ç–‘é—®ï¼Œå¯ä»¥å¯¹ç…§ java ä»£ç æŸ¥çœ‹ã€‚

#include <vector>
#include <queue>

class Solution {
public:
    int nearestExit(std::vector<std::vector<char>>& maze, std::vector<int>& entrance) {
        int m = maze.size();
        int n = maze[0].size();
        std::vector<std::vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        std::queue<std::vector<int>> queue;
        std::vector<std::vector<bool>> visited(m, std::vector<bool>(n, false));
        queue.push(entrance);
        visited[entrance[0]][entrance[1]] = true;
        
        // å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
        int step = 0;
        while (!queue.empty()) {
            int sz = queue.size();
            step++;
            // æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            for (int i = 0; i < sz; i++) {
                std::vector<int> cur = queue.front();
                queue.pop();
                // æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
                for (const auto& dir : dirs) {
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || maze[x][y] == '+') {
                        continue;
                    }
                    if (x == 0 || x == m - 1 || y == 0 || y == n - 1) {
                        // èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                        return step;
                    }
                    visited[x][y] = true;
                    queue.push({x, y});
                }
            }
        }
        return -1;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# æ³¨æ„ï¼špython ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ã€‚
# æœ¬ä»£ç çš„æ­£ç¡®æ€§å·²é€šè¿‡åŠ›æ‰£éªŒè¯ï¼Œå¦‚æœ‰ç–‘é—®ï¼Œå¯ä»¥å¯¹ç…§ java ä»£ç æŸ¥çœ‹ã€‚

from collections import deque

class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        m = len(maze)
        n = len(maze[0])
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        # BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        queue = deque()
        visited = [[False for _ in range(n)] for _ in range(m)]
        queue.append(entrance)
        visited[entrance[0]][entrance[1]] = True
        # å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
        step = 0
        while queue:
            sz = len(queue)
            step += 1
            # æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            for i in range(sz):
                cur = queue.popleft()
                # æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
                for dir in dirs:
                    x = cur[0] + dir[0]
                    y = cur[1] + dir[1]
                    if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or maze[x][y] == '+':
                        continue
                    if x == 0 or x == m - 1 or y == 0 or y == n - 1:
                        # èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                        return step
                    visited[x][y] = True
                    queue.append([x, y])
        return -1
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        int m = maze.length;
        int n = maze[0].length;
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[m][n];
        queue.offer(entrance);
        visited[entrance[0]][entrance[1]] = true;
        // å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
        int step = 0;
        while (!queue.isEmpty()) {
            int sz = queue.size();
            step++;
            // æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            for (int i = 0; i < sz; i++) {
                int[] cur = queue.poll();
                // æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
                for (int[] dir : dirs) {
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n
                            || visited[x][y] || maze[x][y] == '+') {
                        continue;
                    }
                    if (x == 0 || x == m - 1 || y == 0 || y == n - 1) {
                        // èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                        return step;
                    }
                    visited[x][y] = true;
                    queue.offer(new int[]{x, y});
                }
            }
        }
        return -1;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// æ³¨æ„ï¼šgo ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ã€‚
// æœ¬ä»£ç çš„æ­£ç¡®æ€§å·²é€šè¿‡åŠ›æ‰£éªŒè¯ï¼Œå¦‚æœ‰ç–‘é—®ï¼Œå¯ä»¥å¯¹ç…§ java ä»£ç æŸ¥çœ‹ã€‚

// BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
func nearestExit(maze [][]byte, entrance []int) int {
    m := len(maze)
    n := len(maze[0])
    dirs := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}
    
    queue := make([][]int, 0)
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }
    
    queue = append(queue, entrance)
    visited[entrance[0]][entrance[1]] = true
    
    // å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
    step := 0
    for len(queue) > 0 {
        sz := len(queue)
        step++
        // æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
        for i := 0; i < sz; i++ {
            cur := queue[0]
            queue = queue[1:]
            // æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
            for _, dir := range dirs {
                x := cur[0] + dir[0]
                y := cur[1] + dir[1]
                if x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || maze[x][y] == '+' {
                    continue
                }
                if x == 0 || x == m-1 || y == 0 || y == n-1 {
                    // èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                    return step
                }
                visited[x][y] = true
                queue = append(queue, []int{x, y})
            }
        }
    }
    return -1
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// æ³¨æ„ï¼šjavascript ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ã€‚
// æœ¬ä»£ç çš„æ­£ç¡®æ€§å·²é€šè¿‡åŠ›æ‰£éªŒè¯ï¼Œå¦‚æœ‰ç–‘é—®ï¼Œå¯ä»¥å¯¹ç…§ java ä»£ç æŸ¥çœ‹ã€‚

var nearestExit = function(maze, entrance) {
    const m = maze.length;
    const n = maze[0].length;
    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
    const queue = [];
    const visited = Array.from({ length: m }, () => Array(n).fill(false));
    queue.push(entrance);
    visited[entrance[0]][entrance[1]] = true;
    // å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
    let step = 0;
    while (queue.length) {
        const sz = queue.length;
        step++;
        // æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
        for (let i = 0; i < sz; i++) {
            const cur = queue.shift();
            // æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
            for (const dir of dirs) {
                const x = cur[0] + dir[0];
                const y = cur[1] + dir[1];
                if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || maze[x][y] === '+') {
                    continue;
                }
                if (x === 0 || x === m - 1 || y === 0 || y === n - 1) {
                    // èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                    return step;
                }
                visited[x][y] = true;
                queue.push([x, y]);
            }
        }
    }
    return -1;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>ğŸƒğŸƒ ç®—æ³•å¯è§†åŒ– ğŸƒğŸƒ</strong></summary><div id="data_nearest-exit-from-entrance-in-maze"  category="leetcode" ></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_nearest-exit-from-entrance-in-maze"></div></div>
</details><hr /><br />

</div>
</details>
</div>


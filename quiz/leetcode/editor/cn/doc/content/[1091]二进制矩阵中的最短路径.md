<p>给你一个 <code>n x n</code> 的二进制矩阵 <code>grid</code> 中，返回矩阵中最短 <strong>畅通路径</strong> 的长度。如果不存在这样的路径，返回 <code>-1</code> 。</p>

<p>二进制矩阵中的 畅通路径 是一条从 <strong>左上角</strong> 单元格（即，<code>(0, 0)</code>）到 右下角 单元格（即，<code>(n - 1, n - 1)</code>）的路径，该路径同时满足下述要求：</p>

<ul> 
 <li>路径途经的所有单元格的值都是 <code>0</code> 。</li> 
 <li>路径中所有相邻的单元格应当在 <strong>8 个方向之一</strong> 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li> 
</ul>

<p><strong>畅通路径的长度</strong> 是该路径途经的单元格总数。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/example1_1.png" style="width: 500px; height: 234px;" /> 
<pre>
<strong>输入：</strong>grid = [[0,1],[1,0]]
<strong>输出：</strong>2
</pre>

<p><strong>示例 2：</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/example2_1.png" style="height: 216px; width: 500px;" /> 
<pre>
<strong>输入：</strong>grid = [[0,0,0],[1,1,0],[1,1,0]]
<strong>输出：</strong>4
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>grid = [[1,0,0],[1,1,0],[1,1,0]]
<strong>输出：</strong>-1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>n == grid.length</code></li> 
 <li><code>n == grid[i].length</code></li> 
 <li><code>1 &lt;= n &lt;= 100</code></li> 
 <li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>广度优先搜索 | 数组 | 矩阵</details><br>

<div>👍 404, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：为满足广大读者的需求，网站上架 [速成目录](https://labuladong.online/algo/intro/quick-learning-plan/)，如有需要可以看下，谢谢大家的支持~**

<details><summary><strong>labuladong 思路</strong></summary>


<div id="labuladong_solution_zh">

## 基本思路

这道题的思路应该很明显，[BFS 算法](https://labuladong.online/algo/essential-technique/bfs-framework/) 肯定可以解决。

一般我们二维矩阵相关的题目只允许上下左右移动，这里还允许斜着移动，只要稍微改一改 [BFS 算法框架](https://labuladong.online/algo/essential-technique/bfs-framework/) 中的方向数组 `dirs` 即可。

**详细题解**：
  - [【练习】BFS 经典习题 I](https://labuladong.online/algo/problem-set/bfs/)

</div>





<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {
            return -1;
        }

        queue<pair<int, int>> q;
        // 需要记录走过的路径，避免死循环
        vector<vector<bool>> visited(m, vector<bool>(n, false));

        // 初始化队列，从 (0, 0) 出发
        q.push({0, 0});
        visited[0][0] = true;
        int pathLen = 1;

        // 执行 BFS 算法框架，从值为 0 的坐标开始向八个方向扩散
        vector<vector<int>> dirs = {
            {0, 1}, {0, -1}, {1, 0}, {-1, 0},
            {1, 1}, {1, -1}, {-1, 1}, {-1, -1}
        };
        while (!q.empty()) {
            int sz = q.size();
            for (int __ = 0; __ < sz; __++) {
                auto cur = q.front();
                q.pop();
                int x = cur.first, y = cur.second;
                if (x == m - 1 && y == n - 1) {
                    return pathLen;
                }
                // 向八个方向扩散
                for (int i = 0; i < 8; i++) {
                    int nextX = x + dirs[i][0];
                    int nextY = y + dirs[i][1];
                    // 确保相邻的这个坐标没有越界且值为 0 且之前没有走过
                    if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n
                        && grid[nextX][nextY] == 0 && !visited[nextX][nextY]) {
                        q.push({nextX, nextY});
                        visited[nextX][nextY] = true;
                    }
                }
            }
            pathLen++;
        }
        return -1;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

from collections import deque

class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        if grid[0][0] == 1 or grid[m - 1][n - 1] == 1:
            return -1

        q = deque()
        # 需要记录走过的路径，避免死循环
        visited = [[False] * n for _ in range(m)]

        # 初始化队列，从 (0, 0) 出发
        q.append((0, 0))
        visited[0][0] = True
        pathLen = 1

        # 执行 BFS 算法框架，从值为 0 的坐标开始向八个方向扩散
        dirs = [
            (0, 1), (0, -1), (1, 0), (-1, 0),
            (1, 1), (1, -1), (-1, 1), (-1, -1)
        ]
        while q:
            sz = len(q)
            for _ in range(sz):
                x, y = q.popleft()
                if x == m - 1 and y == n - 1:
                    return pathLen
                # 向八个方向扩散
                for dx, dy in dirs:
                    nextX, nextY = x + dx, y + dy
                    # 确保相邻的这个坐标没有越界且值为 0 且之前没有走过
                    if 0 <= nextX < m and 0 <= nextY < n and grid[nextX][nextY] == 0 and not visited[nextX][nextY]:
                        q.append((nextX, nextY))
                        visited[nextX][nextY] = True
            pathLen += 1
        return -1
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {
            return -1;
        }

        Queue<int[]> q = new LinkedList<>();
        // 需要记录走过的路径，避免死循环
        boolean[][] visited = new boolean[m][n];

        // 初始化队列，从 (0, 0) 出发
        q.offer(new int[]{0, 0});
        visited[0][0] = true;
        int pathLen = 1;

        // 执行 BFS 算法框架，从值为 0 的坐标开始向八个方向扩散
        int[][] dirs = new int[][]{
                {0, 1}, {0, -1}, {1, 0}, {-1, 0},
                {1, 1}, {1, -1}, {-1, 1}, {-1, -1}
        };
        while (!q.isEmpty()) {
            int sz = q.size();
            for (int __ = 0; __ < sz; __++) {
                int[] cur = q.poll();
                int x = cur[0], y = cur[1];
                if (x == m - 1 && y == n - 1) {
                    return pathLen;
                }
                // 向八个方向扩散
                for (int i = 0; i < 8; i++) {
                    int nextX = x + dirs[i][0];
                    int nextY = y + dirs[i][1];
                    // 确保相邻的这个坐标没有越界且值为 0 且之前没有走过
                    if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n
                            && grid[nextX][nextY] == 0 && !visited[nextX][nextY]) {
                        q.offer(new int[]{nextX, nextY});
                        visited[nextX][nextY] = true;
                    }
                }
            }
            pathLen++;
        }
        return -1;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

func shortestPathBinaryMatrix(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])
    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {
        return -1
    }

    q := make([][2]int, 0)
    // 需要记录走过的路径，避免死循环
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }

    // 初始化队列，从 (0, 0) 出发
    q = append(q, [2]int{0, 0})
    visited[0][0] = true
    pathLen := 1

    // 执行 BFS 算法框架，从值为 0 的坐标开始向八个方向扩散
    dirs := [8][2]int{
        {0, 1}, {0, -1}, {1, 0}, {-1, 0},
        {1, 1}, {1, -1}, {-1, 1}, {-1, -1},
    }
    
    for len(q) > 0 {
        sz := len(q)
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            x, y := cur[0], cur[1]
            if x == m-1 && y == n-1 {
                return pathLen
            }
            // 向八个方向扩散
            for j := 0; j < 8; j++ {
                nextX := x + dirs[j][0]
                nextY := y + dirs[j][1]
                // 确保相邻的这个坐标没有越界且值为 0 且之前没有走过
                if nextX >= 0 && nextX < m && nextY >= 0 && nextY < n &&
                    grid[nextX][nextY] == 0 && !visited[nextX][nextY] {
                    q = append(q, [2]int{nextX, nextY})
                    visited[nextX][nextY] = true
                }
            }
        }
        pathLen++
    }
    return -1
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

var shortestPathBinaryMatrix = function(grid) {
    let m = grid.length, n = grid[0].length;
    if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {
        return -1;
    }

    let q = [];
    // 需要记录走过的路径，避免死循环
    let visited = Array.from({ length: m }, () => Array(n).fill(false));

    // 初始化队列，从 (0, 0) 出发
    q.push([0, 0]);
    visited[0][0] = true;
    let pathLen = 1;

    // 执行 BFS 算法框架，从值为 0 的坐标开始向八个方向扩散
    let dirs = [
        [0, 1], [0, -1], [1, 0], [-1, 0],
        [1, 1], [1, -1], [-1, 1], [-1, -1]
    ];
    while (q.length > 0) {
        let sz = q.length;
        for (let __ = 0; __ < sz; __++) {
            let cur = q.shift();
            let x = cur[0], y = cur[1];
            if (x == m - 1 && y == n - 1) {
                return pathLen;
            }
            // 向八个方向扩散
            for (let i = 0; i < 8; i++) {
                let nextX = x + dirs[i][0];
                let nextY = y + dirs[i][1];
                // 确保相邻的这个坐标没有越界且值为 0 且之前没有走过
                if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n
                    && grid[nextX][nextY] == 0 && !visited[nextX][nextY]) {
                    q.push([nextX, nextY]);
                    visited[nextX][nextY] = true;
                }
            }
        }
        pathLen++;
    }
    return -1;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🌈🌈 算法可视化 🌈🌈</strong></summary><div id="data_shortest-path-in-binary-matrix"  category="leetcode" ></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_shortest-path-in-binary-matrix"></div></div>
</details><hr /><br />

</div>
</details>
</div>


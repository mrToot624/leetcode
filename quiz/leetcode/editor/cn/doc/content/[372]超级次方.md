<p>你的任务是计算&nbsp;<code>a<sup>b</sup></code>&nbsp;对&nbsp;<code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>a = 2, b = [3]
<strong>输出：</strong>8
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>a = 2, b = [1,0]
<strong>输出：</strong>1024
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>a = 1, b = [4,3,3,8,5,2]
<strong>输出：</strong>1
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>a = 2147483647, b = [2,0,0]
<strong>输出：</strong>1198
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= a &lt;= 2<sup>31</sup> - 1</code></li> 
 <li><code>1 &lt;= b.length &lt;= 2000</code></li> 
 <li><code>0 &lt;= b[i] &lt;= 9</code></li> 
 <li><code>b</code> 不含前导 0</li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>数学 | 分治</details><br>

<div>👍 351, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：为满足广大读者的需求，网站上架 [速成目录](https://labuladong.online/algo/intro/quick-learning-plan/)，如有需要可以看下，谢谢大家的支持~**



<p><strong><a href="https://labuladong.online/algo/frequency-interview/quick-power/" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>


<div id="labuladong_solution_zh">

## 基本思路

利用指数的性质，显然：

![](https://labuladong.online/algo/images/superPower/formula1.png)

我们的老读者肯定已经敏感地意识到了，这就是递归的标志，因为问题的规模缩小了：

```java
    superPow(a, [1,5,6,4])
=>  superPow(a, [1,5,6])
```

把上述逻辑翻译成代码即可。

由于结果很大，题目要求求模，那么关于求模运算，这里有必要强调一个推论：

**`(a * b) % k = (a % k)(b % k) % k`**

**也就是说，对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模**。证明见详细题解。

**详细题解**：
  - [如何高效进行模幂运算](https://labuladong.online/algo/frequency-interview/quick-power/)

</div>





<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

#include <vector>

class Solution {
private:
    int base = 1337;

    // 计算 a 的 k 次方然后与 base 求模的结果
    int mypow(int a, int k) {
        // 对因子求模
        a %= base;
        int res = 1;
        for (int i = 0; i < k; i++) {
            // 这里有乘法，是潜在的溢出点
            res *= a;
            // 对乘法结果求模
            res %= base;
        }
        return res;
    }

public:
    int superPow(int a, std::vector<int>& b) {
        if (b.empty()) return 1;
        int last = b.back();
        b.pop_back();

        int part1 = mypow(a, last);
        int part2 = mypow(superPow(a, b), 10);
        // 每次乘法都要求模
        return (part1 * part2) % base;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

class Solution:
    def __init__(self):
        self.base = 1337

    # 计算 a 的 k 次方然后与 base 求模的结果
    def mypow(self, a: int, k: int) -> int:
        # 对因子求模
        a %= self.base
        res = 1
        for i in range(k):
            # 这里有乘法，是潜在的溢出点
            res *= a
            # 对乘法结果求模
            res %= self.base
        return res

    def superPow(self, a: int, b: List[int]) -> int:
        if len(b) == 0:
            return 1
        last = b[-1]
        newB = b[:-1]

        part1 = self.mypow(a, last)
        part2 = self.mypow(self.superPow(a, newB), 10)
        # 每次乘法都要求模
        return (part1 * part2) % self.base
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    private int base = 1337;

    // 计算 a 的 k 次方然后与 base 求模的结果
    private int mypow(int a, int k) {
        // 对因子求模
        a %= base;
        int res = 1;
        for (int i = 0; i < k; i++) {
            // 这里有乘法，是潜在的溢出点
            res *= a;
            // 对乘法结果求模
            res %= base;
        }
        return res;
    }

    public int superPow(int a, int[] b) {
        if (b.length == 0) return 1;
        int last = b[b.length - 1];
        int[] newB = new int[b.length - 1];
        System.arraycopy(b, 0, newB, 0, b.length - 1);

        int part1 = mypow(a, last);
        int part2 = mypow(superPow(a, newB), 10);
        // 每次乘法都要求模
        return (part1 * part2) % base;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

const base = 1337

// 计算 a 的 k 次方然后与 base 求模的结果
func mypow(a, k int) int {
    // 对因子求模
    a %= base
    res := 1
    for i := 0; i < k; i++ {
        // 这里有乘法，是潜在的溢出点
        res *= a
        // 对乘法结果求模
        res %= base
    }
    return res
}

func superPow(a int, b []int) int {
    if len(b) == 0 {
        return 1
    }
    last := b[len(b)-1]
    newB := make([]int, len(b)-1)
    copy(newB, b[:len(b)-1])

    part1 := mypow(a, last)
    part2 := mypow(superPow(a, newB), 10)
    // 每次乘法都要求模
    return (part1 * part2) % base
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照 java 代码查看。

var superPow = function(a, b) {
    const base = 1337;

    // 计算 a 的 k 次方然后与 base 求模的结果
    var mypow = function(a, k) {
        // 对因子求模
        a %= base;
        let res = 1;
        for (let i = 0; i < k; i++) {
            // 这里有乘法，是潜在的溢出点
            res *= a;
            // 对乘法结果求模
            res %= base;
        }
        return res;
    };

    if (b.length === 0) return 1;
    let last = b.pop();

    let part1 = mypow(a, last);
    let part2 = mypow(superPow(a, b), 10);
    // 每次乘法都要求模
    return (part1 * part2) % base;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>👾👾 算法可视化 👾👾</strong></summary><div id="data_super-pow"  category="leetcode" ></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_super-pow"></div></div>
</details><hr /><br />

</div>
</details>
</div>

